/*
kioport.c

Author: Palacios Javier
Last Updated: 4/03/2005
Ing. Electronics
This file is generated by SevenCat's DDK Wizard
 */
#include <ntddk.h>
#include "kioport.h"

#if DBG
#define dprintf DbgPrint
#else
#define dprintf
#endif

#define kprintf DbgPrint
#define NT_DEVICE_NAME	L"\\Device\\kioport"
#define DOS_DEVICE_NAME L"\\DosDevices\\kioport"

///for me///////////////////////////////////////////////////////////////////////////////
#define    IOPM_SIZE    0x2000
typedef UCHAR IOPM[IOPM_SIZE];
IOPM *IOPM_local = 0;

void Ke386SetIoAccessMap(int, IOPM *);
void Ke386QueryIoAccessMap(int, IOPM *);
void Ke386IoSetAccessProcess(PEPROCESS, int);

////Prototipos de funciones///////////////////////////////////////////////////////////////
NTSTATUS kioportDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP pIrp);	 //s
NTSTATUS kioportCreateDispatch(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);	  //s
NTSTATUS PsLookupProcessByProcessId(IN ULONG ulProcId,OUT struct _EPROCESS ** pEProcess);  //s
VOID kioportUnload(IN PDRIVER_OBJECT DriverObject);	 ///s
NTSTATUS kioportDispatchClose(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp);
///////////////////////////////////////////////////////////////////////////////////////

/***************************************************************************************
//Funcion principal de entrada del Driver equivale a main()
***************************************************************************************/
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject,IN PUNICODE_STRING RegistryPath)
{
	NTSTATUS ntStatus;
	PDEVICE_OBJECT DeviceObject = NULL;
	WCHAR NameBuffer[] = L"\\Device\\kioport";
    WCHAR DOSNameBuffer[] = L"\\DosDevices\\kioport";
    UNICODE_STRING uniNameString, uniDOSString;

    KdPrint( ("KIOPORT: Kioport V1.0 02/04/2005 esta cargandose....") );

    IOPM_local = MmAllocateNonCachedMemory(sizeof(IOPM));
    if(IOPM_local == 0) return STATUS_INSUFFICIENT_RESOURCES;

    RtlFillMemory(IOPM_local, sizeof(IOPM), 0xFF);

    KdPrint( ("KIOPORT: Memory Allocated at %X\n",IOPM_local) );

    RtlInitUnicodeString(&uniNameString, NameBuffer);
    RtlInitUnicodeString(&uniDOSString, DOSNameBuffer);

    ntStatus = IoCreateDevice(DriverObject, 
                            0,
                            &uniNameString,
                            FILE_DEVICE_UNKNOWN,
                            0, 
                            FALSE, 
                            &DeviceObject);

    if(!NT_SUCCESS(ntStatus))
        return ntStatus;

    ntStatus = IoCreateSymbolicLink (&uniDOSString, &uniNameString);

    if (!NT_SUCCESS(ntStatus))
        return ntStatus;

    DriverObject->MajorFunction[IRP_MJ_CREATE] = kioportCreateDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = kioportDeviceControl;
	DriverObject->MajorFunction[IRP_MJ_CLOSE]          = kioportDispatchClose;
    DriverObject->DriverUnload = kioportUnload;

    return STATUS_SUCCESS;
	

}
////////////////////////////////////////////////////////////////////////////////////////////////
NTSTATUS kioportCreateDispatch(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
{
	dprintf("kioport IRP_MJ_CREATE en DEBUG\n");

	Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return STATUS_SUCCESS;
}


NTSTATUS kioportDispatchClose(IN PDEVICE_OBJECT DeviceObject,IN PIRP Irp)
{
	NTSTATUS ntStatus;

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	dprintf("kioport IRP_MJ_CLOSE\n");

	ntStatus = Irp->IoStatus.Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return ntStatus;
}



NTSTATUS kioportDeviceControl(IN PDEVICE_OBJECT DeviceObject,IN PIRP pIrp)
{
	PIO_STACK_LOCATION  irpSp;
    NTSTATUS            ntStatus = STATUS_SUCCESS;   

    ULONG               inBufLength;   /* Input buffer length */
    ULONG               outBufLength;  /* Output buffer length */
    ULONG               inBuf;         /* Pointer to Input and output buffer */

    PUCHAR              CharBuffer; 
    PUSHORT             ShortBuffer;
    PULONG              LongBuffer;
    PVOID               ioBuffer;

    USHORT Offset;
    UCHAR Value;
 
    ULONG ProcessID;    
    struct _EPROCESS *Process;

    irpSp = IoGetCurrentIrpStackLocation( pIrp );
    inBufLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    outBufLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    ioBuffer    = pIrp->AssociatedIrp.SystemBuffer;

    CharBuffer  = (PUCHAR) ioBuffer;
    ShortBuffer = (PUSHORT) ioBuffer;
    LongBuffer  = (PULONG) ioBuffer;

    switch ( irpSp->Parameters.DeviceIoControl.IoControlCode )
     {
      case IOCTL_IOPM_RESTRICT_ALL_ACCESS:

            KdPrint( ("KIOPORT: IOCTL_IOPM_RESTRICT_ALL_ACCESS - RTLFillMemory") );
            RtlFillMemory(IOPM_local, sizeof(IOPM), 0xFF);
            pIrp->IoStatus.Information = 0; /* Output Buffer Size */
            ntStatus = STATUS_SUCCESS;
            break;

      case IOCTL_IOPM_ALLOW_EXCUSIVE_ACCESS:

            KdPrint( ("KIOPORT: IOCTL_IOPM_ALLOW_EXCUSIVE_ACCESS - RTLZeroMemory") );
            RtlZeroMemory(IOPM_local, sizeof(IOPM));
            pIrp->IoStatus.Information = 0; /* Output Buffer Size */
            ntStatus = STATUS_SUCCESS;
            break;

      case IOCTL_SET_IOPM: 

            KdPrint( ("KIOPORT: IOCTL_SET_IOPM - Set IO Permission Bitmap") );
            if (inBufLength >= 3) {
                Offset = ShortBuffer[0];
                if (Offset >= 0x2000) {
                      ntStatus = STATUS_ARRAY_BOUNDS_EXCEEDED;
                      break;
                     }
                Value  = CharBuffer[2];
                KdPrint( ("KIOPORT: Offset = %X, Value = %X\n",Offset,Value) );
                *(*IOPM_local + Offset) = Value;
                ntStatus = STATUS_SUCCESS;
            } else ntStatus = STATUS_BUFFER_TOO_SMALL;
            pIrp->IoStatus.Information = 0; /* Output Buffer Size */
            ntStatus = STATUS_SUCCESS;
            break;

      case IOCTL_ENABLE_IOPM_ON_PROCESSID: 

            KdPrint( ("KIOPORT: IOCTL_ENABLE_IOPM_ON_PROCESSID") );
            if (inBufLength >= 4) {
                ProcessID = LongBuffer[0];
                KdPrint( ("KIOPORT: ProcessID Received is %d\n",ProcessID) );
                PsLookupProcessByProcessId(ProcessID, &Process);
                KdPrint( ("KIOPORT: Pointer to Process is %X\n",Process) );
                KdPrint( ("KIOPORT: Address = %X\n",*(*IOPM_local + 0x6F) ) );
                Ke386SetIoAccessMap(1, IOPM_local);
                Ke386IoSetAccessProcess(Process, 1);
                ntStatus = STATUS_SUCCESS;
            } else ntStatus = STATUS_BUFFER_TOO_SMALL;
            pIrp->IoStatus.Information = 0; /* Output Buffer Size */
            ntStatus = STATUS_SUCCESS;
            break;
        
      case IOCTL_READ_PORT_UCHAR:
 
            if ((inBufLength >= 2) && (outBufLength >= 1)) {
                KdPrint( ("KIOPORT: IOCTL_READ_PORT_UCHAR 0x%X",ShortBuffer[0]) );
                (UCHAR)Value = READ_PORT_UCHAR((PUCHAR)ShortBuffer[0]);
                KdPrint( ("KIOPORT: Value Read %X",Value) );
                CharBuffer[0] = Value;
            } else ntStatus = STATUS_BUFFER_TOO_SMALL;
            pIrp->IoStatus.Information = 1; /* Output Buffer Size */
            ntStatus = STATUS_SUCCESS;
            break;

      case IOCTL_WRITE_PORT_UCHAR:
            if (inBufLength >= 3) {
                KdPrint( ("KIOPORT: IOCTL_WRITE_PORT_UCHAR(0x%X,0x%X)",ShortBuffer[0], CharBuffer[2]) );
                WRITE_PORT_UCHAR((PUCHAR)ShortBuffer[0], CharBuffer[2]);
            } else ntStatus = STATUS_BUFFER_TOO_SMALL;
            pIrp->IoStatus.Information = 0; /* Output Buffer Size */
            ntStatus = STATUS_SUCCESS;
            break;

      default:
            KdPrint( ("KIOPORT: Unsupported IOCTL Call\n") );
            ntStatus = STATUS_UNSUCCESSFUL;
            pIrp->IoStatus.Information = 0;
            break;

    }
    pIrp->IoStatus.Status = ntStatus;
    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    return ntStatus;
}


VOID kioportUnload(IN PDRIVER_OBJECT DriverObject)
{
	// Free any resources
	
	WCHAR DOSNameBuffer[] = DOS_DEVICE_NAME;
    UNICODE_STRING uniDOSString;

    KdPrint( ("KIOPORT: KioPort esta descargandose...") );

    if(IOPM_local) MmFreeNonCachedMemory(IOPM_local, sizeof(IOPM));
    RtlInitUnicodeString(&uniDOSString, DOSNameBuffer);
    IoDeleteSymbolicLink (&uniDOSString);
    IoDeleteDevice(DriverObject->DeviceObject);

	KdPrint( ("     Hecho\n") );
}

